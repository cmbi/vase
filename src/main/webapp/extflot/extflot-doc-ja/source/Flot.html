<html>
<head>
<title>The source code</title>
<link href="../resources/prettify/prettify.css" type="text/css"
	rel="stylesheet" />
<script type="text/javascript" src="../resources/prettify/prettify.js"></script>
</head>
<body onload="prettyPrint();">
	<pre class="prettyprint lang-js">/* $Id:$
 * vim:sw=2:ts=8:sts=2:et:ft=javascript
 * Released under the MIT license and Ext Open Source License by NCS, December 2008-2009
 *
 * Project Home: http://code.google.com/p/extflot/
 * API Documentation: http://code.google.com/p/extflot/wiki/ApiDocumentation
 * Live Demo: http://extflot.googlecode.com/svn/trunk/index.html
 */

// dummy for no GetText
if (typeof _  != "function") {  _ = function(str) { return str; }; }

<div id="cls-Ext.ux.Flot"></div>/**
 * @class Ext.ux.Flot
 * @extends Ext.BoxComponent
 * <a href='http://code.google.com/p/extflot/'>http://code.google.com/p/extflot/</a>
 * <br>
 * flot �� jQuery ���Ѥ������������饤�֥��Ǥ���
 *   <a href='http://code.google.com/p/flot/'>http://code.google.com/p/flot/</a>
 * <br>
 * Ext Flot �ϰʲ��˰�¸���Ƥ��ޤ���
<pre>
 Ext JS   2.2 and 2.2.1
 flot     0.5 (or latest revision of flot (r148 or later))
(Ext Flot 0.7a)
</pre>
 * <br>
 * flot ���Τ� API �ˤĤ��Ƥ� <a
			href='http://flot.googlecode.com/svn/trunk/API.txt'>http://flot.googlecode.com/svn/trunk/API.txt</a>
 * �򻲾Ȥ��Ƥ���������
 *
 * @constructor
 * @param {Object} config ���ꥪ�֥�������
 */
Ext.ux.Flot = Ext.extend(Ext.BoxComponent, {
  // protected version of Ext Flot
  version: "0.7a",

  <div id="cfg-Ext.ux.Flot-series"></div>/**
   * @cfg {Object} series 
   * flot series option
   */
  <div id="cfg-Ext.ux.Flot-baseSeries"></div>/**
   * @cfg {Object} baseSeries
   * �Ʒ����ɬ���ղä���륪�ץ����
   * Ext.apply �����Τǡ���������ε��Ҥ���äȤ�ͥ���٤��⤤�Ǥ�
   */
  <div id="cfg-Ext.ux.Flot-type"></div>/**
   * @cfg {String} type 
   * �ǡ������Фη�
   * {@link Ext.data.Record.create} �ǻ��Ѥ���ޤ�
   * string int float boolean date
   */
  type: 'auto',
  <div id="cfg-Ext.ux.Flot-sortType"></div>/**
   * @cfg {Function} sortType 
   * {@link Ext.data.SortTypes} �Τ����줫
   * �ǥե���Ȥ� {@link Ext.data.SortTypes.asFloat} �Ǥ�
   * {@link Ext.data.Record.create} �ǻ��Ѥ���ޤ�
   */
  sortType: Ext.data.SortTypes.asFloat,

  <div id="cfg-Ext.ux.Flot-legend"></div>/**
   * @cfg {Object} legend
   * Flot legend options. It is passed to flot with not modified.
   */

  <div id="cfg-Ext.ux.Flot-xaxis"></div>/**
   * @cfg {Object} xaxis
   * flot xaxis
   */
  <div id="cfg-Ext.ux.Flot-yaxis"></div>/**
   * @cfg {Object} yaxis
   * flot yaxis
   */
  <div id="cfg-Ext.ux.Flot-x2axis"></div>/** 
   * @cfg {Object} x2axis
   * flot x2axis
   */
  <div id="cfg-Ext.ux.Flot-y2axis"></div>/**
   * @cfg {Object} y2axis
   * flot y2axis
   */
  <div id="cfg-Ext.ux.Flot-lines"></div>/**
   * @cfg {Object} lines
   * flot lines
   */
  <div id="cfg-Ext.ux.Flot-points"></div>/**
   * @cfg {Object} points
   * flot points
   */
  <div id="cfg-Ext.ux.Flot-bars"></div>/**
   * @cfg {Object} bars
   * flot bars
   */
  <div id="cfg-Ext.ux.Flot-pies"></div>/**
   * @cfg {Object} pies
   * Flot pies
   */
  <div id="cfg-Ext.ux.Flot-shadowSize"></div>/**
   * @cfg {Number} shadowSize
   * flot shadowSize
   */

  <div id="cfg-Ext.ux.Flot-grid"></div>/**
   * @cfg {Object} grid
   * flot grid options
   * �ʲ����ȼ���ĥ�Ǥ�
   * �ǥե���Ȥ� clicable �� hoverable �� on �ˤʤ�ޤ�
   */
  <div id="cfg-Ext.ux.Flot-selection"></div>/**
   * @cfg {Object} selection
   * flot selection option
   * �ʲ����ȼ���ĥ�Ǥ�<br>
   *
<pre>
selection: {
  action:    'select' or 'zoom' or 'move' or null
  appendKey: 'shiftKey' or 'ctrlKey' or 'altKey'
  zoomDirection: 'tb' or 'bt' or 'lr' or 'rl'
  zoomWindow: 'ranges' or 'width' or 'height' or 'expand' or 'shrink'
  cursor: {
    select: 'default'
    zoom:   'crosshair'
    move:   'move'
  }
}
</pre>
   *
   * <li>action ��������ε�ư����ꤷ�ޤ�
   *   <ol>
   *   <li>select �����򤷤��ϰ�����������򤷤ޤ���
   *     shift �����򲡤��ʤ������򤹤�ȡ��ɲä���ޤ���
   *     �̾�ϡ����������򤷤ʤ����ޤ���
   *     �ǥե���Ȥν������Ǥ���
   *   </li>
   *   <li>zoom �����򤷤��ϰϤ˥����।�󤷤ޤ���
   *     ����� = zoom-in ����� = zoom-out
   *   </li>
   *   <li>move �������ϰϤ��ư���ޤ�</li>
   *   </ol>
   * </li>
   * <li>appendKey ���ɲ������Ԥ���������Ǥ�
   *   ����� DOM ���٥�ȤΥ�������̾�ǹԤ��ޤ�
   * </li>
   * <li>zoomDirection �ϥ����।�󡦥����ॢ���ȤΥޥ��������������ꤷ�ޤ�
   * <li>zoomWindow �ϥ����।�󡦥����ॢ���Ȼ��ο�����ɽ���ϰϤη���ˡ�����ꤷ�ޤ���
   *     �ǥե���Ȥ� 'expand' �Ǥ���
   *   <ol>
   *   <li>ranges �������ϰϤ�Ʊ���ˤ��ޤ������ξ�硢�Ĳ��椬���������ȥ��������Ѥ��ޤ�
   *   
				
				<li>width  �������ϰϤ������˥����ष�ޤ�
   *   
				
				<li>height �������ϰϤι⤵����˥����ष�ޤ�
   *   
				
				<li>expand �������ϰϤ���⤵�Τ�����Ĺ���ۤ���Ĺ������ˤ��ޤ�
   *   
				
				<li>shrink �������ϰϤ���⤵�Τ�����û���ۤ���Ĺ������ˤ��ޤ�
   *   
			
			</ol>
   *
<pre>
    �����।��    �����ॢ����
tb: top (���)    bottom (����)
bt: bottom (����) top (���)
lr: left (����)   right (����)
rl: right (����)  left (����)
</pre>
   * </li>
   * <li>cursor �ϳƥ⡼�ɤΥ��������������ꤷ�ޤ�
   * �ʲ��������ǽ�ʤ褦�Ǥ���
<pre>
crosshair, hand, move, text, wait, help, default, auto,
n-resize, s-resize, w-resize, e-resize, 
nw-resize, ne-resize, sw-resize, se-resize
</pre>
   * </li>
   *
   * TODO action ���Ȥ������ΰ�ο����Ѥ�����
   *   flot 0.5 �Ǥ� selection �Υ��ץ�����ưŪ���Ѥ��� I/F ���ʤ�����
   *   plot �򤷤ʤ���ɬ�פ�����
   */
  <div id="cfg-Ext.ux.Flot-crosshair"></div>/**
   * @cfg {Object} crosshair
   * flot crosshair option
   * This is not supported in flot 0.5
   */

  <div id="cfg-Ext.ux.Flot-width"></div>/**
   * @cfg {Integer/String} width
   * ���Υ���ݡ��ͥ�Ȥ���Ǥ���
   * ���꤬�ʤ���硢�Ƥ����Ʊ���ˤʤ�ޤ�
   */
  <div id="cfg-Ext.ux.Flot-height"></div>/**
   * @cfg {Integer/String} height
   * ���Υ���ݡ��ͥ�Ȥι⤵�Ǥ���
   * ���꤬�ʤ���硢�Ƥι⤵��Ʊ���ˤʤ�ޤ�
   */
  <div id="prop-Ext.ux.Flot-store"></div>/**
   * @property store
   * @type Ext.data.JsonStore
   * series �Υǡ�����ߥ顼��󥰤��ޤ�
   */
  <div id="prop-Ext.ux.Flot-clickItem"></div>/**
   * @property clickItem
   * @type Object
   * ľ��� plotclick �� item �Ǥ�
   */
  <div id="prop-Ext.ux.Flot-hoverItem"></div>/**
   * @property hoverItem
   * @type Object 
   * ľ��� plothover �� item �Ǥ�
   */
  <div id="prop-Ext.ux.Flot-baseRanges"></div>/**
   * @property baseRanges
   * @type Object
   * ����(100%)ɽ���κݤ�ɽ���ϰϤǤ�
   * plotselect �η����Ǥ�
   */
  <div id="prop-Ext.ux.Flot-currentRanges"></div>/**
   * @property currentRanges
   * @type Object
   * ����(100%)ɽ���Ǥʤ����θ��ߤ�ɽ���ϰϤǤ�
   * plotselect �η����Ǥ�
   */

  <div id="prop-Ext.ux.Flot-contextMenu"></div>/**
   * @property contextMenu
   * @type Array
   * contextmenu ���٥�Ȥ�ɽ�������˥塼�Ǥ�
   * ����� <pre>new Ext.menu.Menu({ items: this.contextMenu })</pre> �˰��Ϥ���ޤ�
   * �ɲä�����ϡ����󥹥��������� (initComponent()) �ǡ�
   * push �� concat �򤷤Ƥ���������
   */
  contextMenu: [{
    name: 'select',
    text: _('Select'),
    iconCls: 'image_resize_actual',
    handler: function() { this.setSelectionAction('select'); }
  },{
    name: 'zoom',
    text: _('Zoom'),
    iconCls: 'magnifier_zoom',
    handler: function() { this.setSelectionAction('zoom'); }
  },{
    name: 'move',
    text: _('Move'),
    iconCls: 'magnifier__arrow',
    handler: function() { this.setSelectionAction('move'); }
  },'-',{
    name: 'actual',
    text: _('100%'),
    iconCls: 'magnifier_zoom_actual',
    handler: function() { 
      this.currentRanges = this.getRanges();
      this.zoomRatio(1.0); 
    }
  },'-',{
    name: 'selectall',
    text: _('Select All'),
    handler: function() { this.selectAll(); }
  },{
    name: 'unselectall',
    text: _('Unselect All'),
    handler: function() { this.unselectAll(); }
  },'-',{
    name: 'property',
    text: _('Property'),
    iconCls: 'puzzle',
    handler: function() { this.showProperty(); }
  }],

  <div id="prop-Ext.ux.Flot-datapointContextMenu"></div>/**
   * @property datapointContextMenu
   * @type Array 
   * �ǡ����ݥ���Ⱦ�ǥ���å��򤷤�����ɽ��������˥塼�Ǥ�
   * ����å����֤� this.clickItem.page{X|Y} ���� 5 �ԥ��������ξ���
   * ɽ������ޤ�
   */
  datapointContextMenu: [{
    name: 'selectalldatapoint',
    text: _('Select All Points'),
    iconCls: 'flag_plus',
    handler: function() { 
      var item = this.clickItem || this.hoverItem;
      if (item) { this.selectAll(item.series); }
    }
  },{
    name: 'unselectalldatapoint',
    text: _('Unselect All Points'),
    iconCls: 'flag_minus',
    handler: function() { 
      var item = this.clickItem || this.hoverItem;
      if (item) { this.unselectAll(item.series); }
    }
  },'-',{
    name: 'showseries',
    text: _('Show Series'),
    iconCls: 'database_plus',
    handler: function() { 
      var item = this.clickItem || this.hoverItem;
      if (item) { this.setHidden(item.series, false); }
    }
  },{
    name: 'hideseries',
    text: _('Hide Series'),
    iconCls: 'database_minus',
    handler: function() { 
      var item = this.clickItem || this.hoverItem;
      if (item) { this.setHidden(item.series, true); }
    }
  }],

  <div id="cfg-Ext.ux.Flot-basePropertyColumn"></div>/**
   * @cfg {Object} basePropertyColumn
   * PropertyGrid ����������ݤγƥ�����Ŭ�Ѥ��������
   * {@link Ext.grid.ColumnModel} �Υ��ץ����
   */
  <div id="prop-Ext.ux.Flot-propertyCmp"></div>/**
   * @property propertyCmp
   * @type Ext.Component
   * �ץ�ѥƥ���ɽ�����륳��ݡ��ͥ�ȤǤ���
   * ɽ���Υ����ߥ󥰤� 'show' ���٥�Ȥ��äƤ���������
   */

  <div id="cfg-Ext.ux.Flot-tooltip"></div>/**
   * @cfg {Bool/String/Object} tooltip
   * string ��Ϳ�������ϡ�XTemplate �ˤ�ä���������ޤ���
   * Ŭ�Ѥ����� XTemplate �ΰ���ϰʲ��Υ��֥������ȤǤ���
<pre>
{
   tipId:       event.target.id + '-tip',
   pageX:       pos.pageX,
   pageY:       pos.pageY,
   x:           pos.x,
   y:           pos.y,
   0:           item.datapoint[0],
   1:           item.datapoint[1],
   label:       item.series.label,
   color:       item.series.color,
   shadowSize:  item.series.shadowSize,
   dataIndex:   item.dataIndex,
   seriesIndex: item.seriesIndex
}
</pre>
   * <li>true �ξ�硢
   * <pre>
				<div id="{tipId}">{label} ({0}, {1})</div>
			</pre>
   * �ˤʤ�ޤ���</li>
   * <li>Object ��Ϳ������硢Ext.ToolTip �Υ��󥹥ȥ饯���ˤ��Τޤ�
   * ���Ϥ���ޤ�</li>
   * TODO QuickTips �ˤ��б����Ƥ��ޤ���
   */
  tooltip: true,
  <div id="cfg-Ext.ux.Flot-tooltipEvent"></div>/**
   * @cfg {String} tooltipEvent
   * �ġ�����åפ�ɽ�����륤�٥�ȤǤ�
   * �ʲ��� 3 ����λ��������Ĥ��ޤ�
   *  <li>plothover 
   *  <li>plotclick
   *  <li>all (plothover �� plotclick)
   */
  tooltipEvent: 'plothover',
  <div id="prop-Ext.ux.Flot-disableTooltip"></div>/**
   * @property disableTooltip
   * @type Bool
   * �ġ�����åפ�ͭ��̵������ꤷ�ޤ�
   */

  <div id="prop-Ext.ux.Flot-flot"></div>/**
   * @property flot
   * @type Object
   * flot �Υ���ե��󥹥���
   * Read-only �Ǥ�������Ū�˥᥽�åɤ�𤷤ƥ����������Ƥ�������
   */

  // private
  initComponent: function() {
    // ������䴰
    Ext.applyIf(this, {
      grid: {},
      xaxis: {},
      yaxis: {},
      selection: {},
      crosshair: {}
    });
    Ext.applyIf(this.grid, {
      clickable: true,
      hoverable: true
    });
    Ext.applyIf(this.selection, {
      mode:          "xy", 
      action:        'select',
      appendKey:     'shiftKey',
      zoomDirection: 'tb',
      zoomWindow:    'expand',
      cursor: {}
    });
    Ext.applyIf(this.selection.cursor, {
      select: 'default',
      zoom:   'crosshair',
      move:   'move'
    });

    // data �Υߥ顼���
    this.store = this.store || new Ext.data.JsonStore({});

    // ���򤵤줿����
    this.selected = [];

    // ����ƥ����ȥ�˥塼�� Ext.Action ������
    this.actions = {};
    var keys = ['contextMenu', 'datapointContextMenu'];
    for (var k = 0; k < keys.length; k++) {
      var key = keys[k];
      if (this[key]) {
        var menu = [];
        var contextMenu = this[key];
        for (var i = 0, len = contextMenu.length; i < len; i++) {
          if (typeof contextMenu[i] == 'object') {
            var action = new Ext.Action(Ext.apply({scope: this}, contextMenu[i]));
            this.actions[contextMenu[i].name] = action;
            menu.push(action);
          } else {
            menu.push(contextMenu[i]);
          }
        }
        this[key] = menu;
      }
    }

    Ext.ux.Flot.superclass.initComponent.call(this);
    this.addEvents(
      <div id="event-Ext.ux.Flot-click"></div>/**
       * @event click
       * @param {OBject} event
       * Flot ����ݡ��ͥ�ȤΤɤ���������å���������ȯ�Ԥ���ޤ�
       * false ���֤��ȡ�Flot �����ꤵ��Ƥ���ư��򤷤ޤ���
       */
      "click",
      <div id="event-Ext.ux.Flot-dblclick"></div>/**
       * @event dblclick
       * @param {OBject} event
       * false ���֤��ȡ�Flot �����ꤵ��Ƥ���ư��򤷤ޤ���
       */
      "dblclick",
      <div id="event-Ext.ux.Flot-contextmenu"></div>/**
       * @event contextmenu
       * @param {OBject} event
       * false ���֤��ȡ�ɸ��� contextmenu (this.contextMenu) ��ɽ�����ޤ���
       */
      "contextmenu",
      <div id="event-Ext.ux.Flot-beforedraw"></div>/**
       * @event beforedraw
       * flot ��(��)����¹�����ȯ�Ԥ���ޤ�
       * false ���֤��ȡ�Flot �����ꤵ��Ƥ���ư��򤷤ޤ���
       * @param {Ext.ux.Flot} this
       * @param {Object} series
       */
      "beforedraw",
      <div id="event-Ext.ux.Flot-draw"></div>/**
       * @event draw
       * flot ��(��)����¹Ը��ȯ�Ԥ���ޤ�
       * @param {Ext.ux.Flot} this
       * @param {Object} series
       */
      "draw",
      <div id="event-Ext.ux.Flot-plotselected"></div>/**
       * @event plotselected
       * ����ΰ������
       * series.selectable �� true �Ǥ�����Τ�ͭ��Ǥ�
       * false ���֤��ȡ�Flot �����ꤵ��Ƥ���ư��򤷤ޤ���
       * ����ʳ��ξ��ϡ�selection.action �����ꤵ��Ƥ���ư���򤷤ޤ�
       * @param {Ext.ux.Flot} this
       * @param {Object} event ���٥�ȥ��֥�������
       * @param {Object} range �����ϰ϶��
       * {x: xpos, y: ypos, x2: xpos2, y2: ypos2}
       * @param {Object} item ���򤵤줿�����ƥ�
       * null �Ǥʤ��������򤵤줿�ǡ����������äƤ��ޤ�
       * <li>datapoint [0, 2] �Τ褦�ʡ����򤵤줿����Υǡ�����
       * <li>dataIndex ���򤵤줿�ǡ������� data ��Υ���ǥå���
       * <li>series    ���򤵤줿����
       * <li>seriesIndex ���򤵤줿����� data ��Υ���ǥå���
       * <li>pageX     ���򤵤줿���Υ��?�Х륹���꡼����κ�ɸ
       * <li>pageY
       */
      "plotselected",
      <div id="event-Ext.ux.Flot-plotselecting"></div>/**
       * @event plotselecting
       * ����ΰ��������
       * �ΰ�����Υɥ�å���˸ƤӽФ���ޤ���
       * ����� plotselected ��Ʊ�ͤǤ�
       * flot 0.5 �Ǥ�̤�б��Ǥ�
       * @param {Ext.ux.Flot} this
       * @param {Object} event ���٥�ȥ��֥�������
       * @param {Object} range �����ϰ϶��
       * @param {Object} item ���򤵤줿�����ƥ�
       */
      "plotselecting",
      <div id="event-Ext.ux.Flot-plothover"></div>/**
       * @event plothover
       * grid.hoverable �� true �Ǥ�����Τ�ͭ��Ǥ�
       * false ���֤��ȡ�Flot �����ꤵ��Ƥ���ư��򤷤ޤ���
       * �����Х����ޥ������̲ᤷ�Ƥ���ݤ�ȯ�Ԥ���ޤ�
       * item ��������ϡ��������ξ���̲ᤷ�Ƥ��ޤ�
       * @param {Ext.ux.Flot} this
       * @param {Object} event ���٥�ȥ��֥�������
       * @param {Object} pos
       * ����å����줿����
       * {x: xpos, y: ypos, x2: xpos2, y2: ypos2}
       * @param {Object} item ����å����줿�����ƥ�
       * "plotselected" ���٥�Ȥ� item ��Ʊ���Ǥ�
       */
      "plothover",
      <div id="event-Ext.ux.Flot-plotclick"></div>/**
       * @event plotclick
       * clickable �� true �Ǥ�����Τ�ͭ��Ǥ�
       * �����Х���ǥޥ�������å����Ԥ�줿����ȯ�Ԥ���ޤ�
       * item ��������ϡ��������򥯥�å����Ƥ��ޤ�
       * @param {Ext.ux.Flot} this
       * @param {Object} event ���٥�ȥ��֥�������
       * @param {Object} pos
       * ����å����줿����
       * {x: xpos, y: ypos, x2: xpos2, y2: ypos2}
       * @param {Object} item ����å����줿�����ƥ�
       * "plotselected" ���٥�Ȥ� item ��Ʊ���Ǥ�
       */
      "plotclick",
      <div id="event-Ext.ux.Flot-plotshow"></div>/**
       * @event plotshow
       * ����ɽ�����줿
       * @param {Ext.ux.Flot} this
       * @param {Object} series ɽ�����줿����
       */
      "plotshow",
      <div id="event-Ext.ux.Flot-plothide"></div>/**
       * @event plothide
       * ���󤬱����줿
       * @param {Ext.ux.Flot} this
       * @param {Object} series �����줿����
       */
      "plothide",
      <div id="event-Ext.ux.Flot-selectionactionchange"></div>/**
       * @event selectionactionchange
       * @param {Ext.ux.Flot} this
       * @param {String} action ���򤵤줿����
       */
      "selectionactionchange",
      <div id="event-Ext.ux.Flot-selectionchange"></div>/**
       * @event selectionchange
       * �����������ѹ����줿
       * @param {Ext.ux.Flot} this
       * @param {Array} selected ���򤵤줿����
       * getSelected() ��Ʊ�������Ǥ�
       */
      "selectionchange",
      <div id="event-Ext.ux.Flot-legendclick"></div>/**
       * @event legendclick
       * ���㤬����å����줿
       * @param {Ext.ux.Flot} this
       * @param {Ext.Element} legend (legendColorBox ro legendLabel)
       * @param {Object} series �б��������
       * false ���֤��ȡ�Flot �����ꤵ��Ƥ���ư��򤷤ޤ���
       */
      "legendclick");
  },

  <div id="method-Ext.ux.Flot-createStoreData"></div>/**
   * flot ����ǡ��� (series) ���� Ext.data.JsonStore �Ѥ� Object ���������ޤ���
   * ����� Ext.data.JsonStore.loadData() ���ɤ߹��ޤ��뤳�Ȥ��Ǥ��ޤ���
   * metaData ��ޤࡢHttpResponse �Ѥ�Ʊ���������֤��ޤ���
   * �¥ǡ����Υ롼�Ȥ� 'data' �Ǥ���
   * @param {Object} series ���ȥ��ǡ������������Ǥ���
   * ����ʤ��ξ��ϡ����󥹥��󥹤��ݻ�Ƥ������ getData() �����������ޤ���
   * @return {Object} Ext.data.JsonStore loadData() �ѤΥ��֥�������
   */
  createStoreData: function(series) {
    series = series || this.getData();
    var axes = this.getAxes();
    var fields = [];
    var keys = ['xaxis', 'x2axis'];
    for (var k = 0; k < keys.length; k++) {
      fields.push({
        name: keys[k],
        xColumn: true,
        type: this.type,
        sortType: this.sortType
      });
    }
    var hash = {};
    for (var i = 0, len = series.length; i < len; i++) {
      var s = series[i];
      var name = s.label || i;
      var xaxis = (s.xaxis == axes.x2axis) ? 'x2axis' : 'xaxis';
      fields.push({ 
        name: name,
        type: this.type,
        sortType: this.sortType
      });

      for (var j = 0, dlen = s.data.length; j < dlen; j++) {
        var src  = s.data[j];
        if (src) {
          var dest = hash[src[0]] = hash[src[0]] || {};
          dest[xaxis]   = src[0];
          dest[name] = src[1];
        }
      }
    }
    var data = [];
    for (var key in hash) { data.push(hash[key]); }

    return {
      metaData: {
        root: 'data',
        totalProperty: 'total',
        successProperty: 'success',
        sortInfo: { field: 'xaxis', direction: 'ASC' },
        fields: fields
      },
      data:  data,
      total: data.length,
      success: true
    };
  },

  <div id="method-Ext.ux.Flot-createSeries"></div>/**
   * store �Υǡ������˷�����������ޤ�
   * ���������Ʒ���� {@link Ext.data.Store} �Ѥΰʲ��γ�ĥ��ޤ�Ǥ��ޤ�
   *  <li>dataIndex
   *  <li>type
   *  <li>sortType
   * @param {Ext.data.Store} store ���Ѥ���ǡ������ȥ�
   * ���꤬�ʤ��ä����� this.store �����Ѥ���ޤ�
   * @param {String} field X �������ꤹ��ե������
   * dataIndex, name �ν�ǥޥå��󥰤���ޤ�
   * @return {Array} flot �����Ѳ�ǽ�ʷ��������
   */
  createSeries: function(store, xColumn) {
    store = store || this.store;
    if (typeof xColumn == 'undefined') { xColumn = store.xColumn; }
    var i, len;
    var series = [];
    for (i = 0, len = store.fields.keys.length; i < len; i++) {
      var finfo = store.fields.items[i];
      var idx   = finfo.dataIndex || finfo.name;
      if (xColumn == idx) { continue; }
      series.push({
        label:     finfo.name, 
        dataIndex: idx, 
        type:      this.type,
        sortType:  this.sortType,
        data: []
      });
    }
    store.each(function(rec) {
      var series = this.series;
      var store  = this.store;
      var x = rec.get(this.xColumn);
      for (var i = 0, len = series.length; i < len; i++) {
        var val = rec.get(series[i].dataIndex);
        series[i].data.push([x, val]);
      }
    }, { series: series, store: store, xColumn: xColumn });
    return series;
  },

  <div id="method-Ext.ux.Flot-getStore"></div>/**
   * ���Υ��󥹥��󥹤��ݻ�Ƥ��� Store �����ޤ�
   * @return {Ext.data.JsonStore} �ݻ�Ƥ��� JsonStore
   */
  getStore: function() {
    return this.store;
  },

  <div id="method-Ext.ux.Flot-clipData"></div>/**
   * range ��Ϳ�����ΰ��¸�ߤ��Ƥ��� datapoints �򽸤�Ƥ��ޤ�
   * @param {Object} ranges
   * ranges �ϰʲ��γƥ��Ф���� from to ���äƤ��ޤ���
   * from �� to ��ñ�̤ϡ����줾��η�����ͤ�ñ�̤Ǥ��뤳�Ȥ���դ��Ƥ���������
   *  * xaxis yaxis x2axis y2axis
   *    * from to
   * @return {Array} �Ʒ���� range �������
   */
  clipData: function(ranges) {
    var series = this.getData();
    var axes = this.getAxes();
    var clipped = [];
    for (var i = 0, len = series.length; i < len; i++) {
      var s = series[i];
      clipped[i] = {};
      clipped[i].series = s;
      clipped[i].datapoints = [];
      var xaxis = s.xaxis == axes.x2axis ? 'x2axis' : 'xaxis';
      var yaxis = s.yaxis == axes.y2axis ? 'y2axis' : 'yaxis';
      for (var j = 0, n = s.data.length; j < n; j++) {
        var d = s.data[j];
        if (d &&
            ranges[xaxis].from <= d[0] &&
            ranges[xaxis].to   >= d[0] &&
            ranges[yaxis].from <= d[1] &&
            ranges[yaxis].to   >= d[1]) {
          clipped[i].datapoints.push([d[0], d[1]]);
        }
      }
    }
    return clipped;
  },

  // private
  onRender: function(ct, position) {
    if (!this.template) {
      if (!Ext.ux.Flot.flotTemplate) {
        // 0: DOM ID for container
        Ext.ux.Flot.flotTemplate = new Ext.Template('<div id="{0}"></div>');
      }
      this.template = Ext.ux.Flot.flotTemplate;
    }
    var id = this.id || Ext.id(null, 'flot-container');
    var el, targs = [id];

    if (position) {
      el = this.template.insertBefore(position, targs, true);
      //ct = position;
    }else{
      el = this.template.append(ct, targs, true);
    }
    this.el = el;
    if (this.id) { this.el.dom.id = this.el.id = this.id; }
    this.el.setWidth( this.width  || ct.getWidth());
    this.el.setHeight(this.height || ct.getHeight());
    this.el.setStyle('cursor', this.selection.cursor[this.selection.action]);

    // draw el
    var series = this.series;
    if (this.data) { series = this.setupData(this.data, series); }
    if (series) {
      // ����򥻥åȥ��åפ�������
      series = this.setupSeries(series);
      this.plot(series);

      // hidden �ν�������Ԥ�
      series = this.getData();
      for (var i = 0, len = series.length; i < len; i++) {
        var s = series[i];
        if (s.hidden) {
          s.hidden = !s.hidden;
          this.setHidden(s, !s.hidden);
        }
      }
      this.baseRanges = this.getRanges();
    }
  },

  // private
  afterRender: function() {
    Ext.ux.Flot.superclass.afterRender.call(this);
    this.el.on({
      "mousedown":   this.onMouseDown,
      "mouseup":     this.onMouseUp,
      "mouseout":    this.onMouseOut,
      "click":       this.onClick,
      "dblclick":    this.onDblClick,
      "contextmenu": this.onContextMenu,
      scope: this
    });

    $('#' + this.id).bind('plotselected', function(event, range) {
      flot = Ext.getCmp(event.target.id);
      flot.onPlotSelected(event, range);
    });
    $('#' + this.id).bind('plotselecting', function(event, range) {
      flot = Ext.getCmp(event.target.id);
      flot.onPlotSelecting(event, range);
    });
    $('#' + this.id).bind('plothover', function(event, pos, item) {
      flot = Ext.getCmp(event.target.id);
      flot.onPlotHover(event, pos, item);
    });
    $('#' + this.id).bind('plotclick', function(event, pos, item) {
      flot = Ext.getCmp(event.target.id);
      flot.onPlotClick(event, pos, item);
    });

    this.updateAction();

    if (this.tooltip) {
      this.on(this.tooltipEvent, function(flot, event, pos, item) {
        if (item) {
          if (!this.prevTooltipItem || 
              this.prevTooltipItem.datapoint[0] != item.datapoint[0] ||
              this.prevTooltipItem.datapoint[1] != item.datapoint[1] ||
              this.prevTooltipItem.series       != item.series) {
            this.showTooltip(event, pos, item); 
            this.prevTooltipItem = item;
          }
        }
      }, this);
    }
  },

  // private
  onResize: function(adjWidth, adjHeight, rawWidth, rawHeight) {
    //Ext.ux.Flot.superclass.onResize.call(this, adjWidth, adjHeight, rawWidth, rawHeight);
    this.el.setWidth(adjWidth);
    this.el.setHeight(adjHeight);
    try {
      this.plot(this.getData());
    } catch (e) {
      if (typeof e == 'string') {
        this.onResize.defer(200, this, [adjWidth, adjHeight, rawWidth, rawHeight]);
      }
    }
    this.syncSelected();
  },

  // private
  setupLegend: function() {
    // handle click of legend
    var legend_tbody = this.el.query("div.legend > table > tbody")[0];
    if (legend_tbody) {
      var series = this.getData();
      this.legendCmp = new Ext.Element(legend_tbody);
      this.legendEls = {};
      var color_boxes = this.legendCmp.query("tr > td.legendColorBox");
      var labels      = this.legendCmp.query("tr > td.legendLabel");
      for (var i = 0, len = series.length; i < len; i++) {
        var s = series[i];
        var idx = -1;
        for (var j = 0; j < labels.length; j++) {
          var text = labels[j].textContent || labels[j].innerHtml;
          if (text == s.label) { 
            idx = j; 
            break; 
          }
        }
        if (idx >= 0) {
          var cb = new Ext.Element(color_boxes[idx]);
          var lb = new Ext.Element(labels[idx]);
          cb.on('click', this.onLegendClick, this, {series: s});
          lb.on('click', this.onLegendClick, this, {series: s});
          var c = this.legendEls[s.label] || {};
          if (c.hidden != s.hidden) { (s.hidden) ? cb.fadeOut() : cb.fadeIn(); }
          if (s.hidden) { cb.hide(); }
          this.legendEls[s.label] = Ext.apply(c, {
            legendColorBox: cb, 
            legendLabel: lb, 
            series: s,
            hidden: s.hidden
          });
        }
      }
    }
  },

  // private
  onDraw: function() {
    this.setupLegend();
    this.store.loadData(this.createStoreData());
    this.fireEvent('draw', this);
  },

  // private
  onSelectionChange: function() {
    this.updateAction();
    this.fireEvent('selectionchange', this, this.selected);
  },

  // private
  onLegendClick: function(e, legendDom, args) {
    var s = args.series;
    if (this.fireEvent('legendclick', this, Ext.get(legendDom), s) !== false) {
      this.setHidden(s, !s.hidden);
    }
  },

  // private
  onMouseDown: function(e) {
    this.lastEvent = this.mouseDownEvent = Ext.apply({}, e);
  },

  // private
  onMouseUp: function(e) {
    this.lastEvent = this.mouseUpEvent = Ext.apply({}, e);
  },

  // private
  onMouseOut: function(e) {
    this.lastEvent = this.mouseUpEvent = Ext.apply({}, e);
  },

  // private
  onClick: function(e) {
    this.fireEvent("click", this, e);
  },

  // private
  onDblClick: function(e) {
    if (this.fireEvent("dblclick", this, e) !== false) {
      if (this.selection.action == 'select') {
        this;   // nothing to do
      } else {  // zoom, move
        if (this.applyRanges == 'baseRanges') {
          this.applyRanges = 'currentRanges';
        } else {
          this.currentRanges = this.getRanges();
          this.applyRanges = 'baseRanges';
        }
        this.zoom(this[this.applyRanges]);
      }
    }
  },

  // private
  onContextMenu: function(e) {
    if (this.fireEvent("contextmenu", this, e) !== false) {
      var contextMenu = this.contextMenu;
      if (this.clickItem) {
        if (Math.abs(e.xy[0] - this.clickItem.pageX) <= 5 &&
            Math.abs(e.xy[1] - this.clickItem.pageY) <= 5) {
          contextMenu = this.datapointContextMenu || contextMenu;
        }
      }
      if (contextMenu) {
        var menu = new Ext.menu.Menu({ items: contextMenu });
        e.stopEvent();
        menu.showAt(e.getXY());
      }
    }
  },

  // private
  onPlotSelecting: function(event, ranges) {
    this.fireEvent('plotselecting', this, event, ranges);
  },

  // private
  onPlotSelected: function(event, ranges) {
    if (this.fireEvent('plotselected', this, event, ranges) !== false) {
      if (!this.mouseDownEvent || !this.mouseUpEvent) { return; }
      var diff_px = [ 
        this.mouseDownEvent.xy[0] - this.mouseUpEvent.xy[0],
        this.mouseDownEvent.xy[1] - this.mouseUpEvent.xy[1]
      ];
      var axes = this.getAxes();
      var r = {};
      var keys = ['xaxis', 'yaxis', 'x2axis', 'y2axis'], k, axis;

      switch (this.selection.action) {
        case 'select':
          if (!this.lastEvent[this.selection.appendKey]) {this.unselectAll();}
          var d = this.clipData(ranges);
          var changed = false;
          for (var i = 0, len = d.length; i < len; i++) {
            for (var j = 0, dlen = d[i].datapoints.length; j < dlen; j++) {
              if (this.addSelected(d[i].series, d[i].datapoints[j])) { changed = true; }
            }
          }
          if (changed) {this.onSelectionChange();}
          break;
        case 'zoom':
          var xmin, xmax, ymin, ymax;
          var x2min, x2max, y2min, y2max;
          var zoom = {}, zoomin, z;
          var w  = this.el.getWidth();
          var h  = this.el.getHeight();
          var rw = Math.abs(diff_px[0]);
          var rh = Math.abs(diff_px[1]);
          var fix_x = false, fix_y = false;
          switch (this.selection.zoomWindow) {
            case 'ranges': break;
            case 'expand': fix_x = (rw < rh); fix_y = (rw > rh); break;
            case 'shrink': fix_x = (rw > rh); fix_y = (rw < rh); break;
            case 'width':  fix_y = true; break;
            case 'height': fix_x = true; break;
            default: break; // ranges
          }
          for (k = 0; k < keys.length; k++) {
            axis = keys[k];
            if (!axes[axis].used) { 
              zoom[axis] = null;
              continue;
            } 
            zoom[axis] = z = {
              from:        ranges[axis].from,
              to:          ranges[axis].to,
              center:      (ranges[axis].from + ranges[axis].to) / 2,
              min:         axes[axis].min,
              max:         axes[axis].max,
              axisLength:  axes[axis].max - axes[axis].min,
              rangeLength: ranges[axis].to - ranges[axis].from
            };

            var scale = null;
            if        (axis[0] == 'x' && fix_x) {
              scale = rh / rw * w / h;
            } else if (axis[0] == 'y' && fix_y) {
              scale = rw / rh * h / w;
            }
            if (scale !== null) {
              z.fromOrg = z.from;
              z.toOrg   = z.to;
              z.from = z.center + (z.from - z.center) * scale;
              z.to   = z.center + (z.to   - z.center) * scale;
              z.rangeLength = z.to - z.from;
            } 
          }
          switch (this.selection.zoomDirection) {
            case 'tb': zoomin = diff_px[1] >= 0; break;
            case 'bt': zoomin = diff_px[1] <= 0; break;
            case 'lr': zoomin = diff_px[0] >= 0; break;
            case 'rl': zoomin = diff_px[0] <= 0; break;
            default:   zoomin = diff_px[1] >= 0; break; // tb
          }
          for (k = 0; k < keys.length; k++) {
            axis = keys[k];
            z = zoom[axis];
            if (!z) { continue; }
            if (zoomin) {
              r[axis] = { min: z.from, max: z.to };
            } else {
              r[axis] = {
                min: z.min + (z.min - z.from) * z.axisLength / z.rangeLength,
                max: z.max + (z.max - z.to)   * z.axisLength / z.rangeLength
              };
            }
          }
          this.zoom(r);
          break;
        case 'move':
          var to_left   = (diff_px[0] <= 0) ? true : false;
          var to_bottom = (diff_px[1] >= 0) ? true : false;
          for (k = 0; k < keys.length; k++) {
            axis = keys[k];
            if (!axes[axis].used) { continue; }
            var diff = ranges[axis].to  - ranges[axis].from;
            diff = ((axis[0] == 'x') ? to_left : to_bottom) ? -diff: diff;
            r[axis] = {
              min: axes[axis].min + diff, 
              max: axes[axis].max + diff
            };
          }
          this.zoom(r);
          break;
        default:
          break;
      }
    }
  },

  // private
  onPlotHover: function(event, pos, item)  {
    this.hoverItem = item;
    this.fireEvent('plothover', this, event, pos, item);
  },

  // private
  onPlotClick: function(event, pos, item)  {
    this.clickItem = item;
    if (this.fireEvent('plotclick', this, event, pos, item) !== false) {
      if (item) {
        if (item.series.selectable) {
          if (!this.lastEvent[this.selection.appendKey]) {this.unselectAll();}
          if (!this.addSelected(item.series, item.datapoint)) {
            this.removeSelected(item.series, item.datapoint);
          }
          this.onSelectionChange();
        }
      } else {
        if (!this.lastEvent[this.selection.appendKey]) { this.unselectAll(); }
      }
    }
  },

  <div id="method-Ext.ux.Flot-setSelectionAction"></div>/**
   * �ϰ��������ư������ꤷ�ޤ�
   * @param {String} action 'select' or 'move' or 'zoom'
   */
  setSelectionAction: function(action) {
    this.selection.action = action;
    this.el.setStyle('cursor', this.selection.cursor[this.selection.action]);
    this.updateAction();
    this.fireEvent('selectionactionchange', this, action);
  },

  <div id="method-Ext.ux.Flot-getSelectionAction"></div>/**
   * �����Ȥ��ϰ��������ư�������������ޤ�
   * @return {String} select zoom move �Τ����줫
   */
  getSelectionAction: function() {
    return this.selection.action;
  },

  <div id="method-Ext.ux.Flot-getRanges"></div>/**
   * �����Ȥ�ɽ���ϰϤ�������ޤ�
   * @return ɽ���ϰϾ���
   */
  getRanges: function() {
    var series = this.getData();
    var axes   = this.getAxes();
    var r = {};
    if (axes.xaxis)  { r.xaxis  = {min: axes.xaxis.min,  max: axes.xaxis.max};}
    if (axes.yaxis)  { r.yaxis  = {min: axes.yaxis.min,  max: axes.yaxis.max};}
    if (axes.x2axis) { r.x2axis = {min: axes.x2axis.min, max: axes.x2axis.max};}
    if (axes.y2axis) { r.y2axis = {min: axes.y2axis.min, max: axes.y2axis.max};}
    return r;
  },

  <div id="method-Ext.ux.Flot-zoom"></div>/**
   * ɽ���ΰ�򥺡��ष�ޤ���
   * �����।�󤹤뤫�����ॢ���Ȥ��뤫�ϡ����ߤ��ΰ��Ϳ�����ΰ�Ȥδط��ˤ��ޤ�
   * @param {Object} range �����ह���ϰ�
   */
  zoom: function(ranges) {
    var keys = ['xaxis', 'yaxis', 'x2axis', 'y2axis'];
    for (var k = 0; k < keys.length; k++) {
      // from to -> min max
      var key = keys[k];
      var r = ranges[key];
      if (r) {
        if (typeof r.min == 'undefined') r.min = r.from;
        if (typeof r.max == 'undefined') r.max = r.to;
        Ext.apply(this[key], r);
      }
    }
    this.plot(this.getData());
  },

  <div id="method-Ext.ux.Flot-zoomRatio"></div>/**
   * �����Ȥ�ɽ���ΰ���Ф�����Ψ�ǥ����ष�ޤ���
   * @param {Number} ratio 1.0 �� 100% �Ǥ�
   */
  zoomRatio: function(ratio) {
    var b = this.baseRanges;
    var r = {};
    if (b.xaxis)  { r.xaxis  = {min: b.xaxis.min  * ratio, max: b.xaxis.max  * ratio}; }
    if (b.yaxis)  { r.yaxis  = {min: b.yaxis.min  * ratio, max: b.yaxis.max  * ratio}; }
    if (b.x2axis) { r.x2axis = {min: b.x2axis.min * ratio, max: b.x2axis.max * ratio}; }
    if (b.y2axis) { r.y2axis = {min: b.y2axis.min * ratio, max: b.y2axis.max * ratio}; }
    this.zoom(r);
  },

  // private
  syncSelected: function() {
    for (var i = 0; i < this.selected.length; i++) {
      var selected = this.selected[i];
      selected.series = this.findSeries(selected.series.id);
      for (var j = 0; j < selected.datapoints.length; j++) {
        this.highlight(selected.series, selected.datapoints[j]);
      }
    }
  },

  // private
  addSelectedPoint: function(selected, datapoint) {
    i = selected.datapoints.indexOf(datapoint);
    if (i < 0) {
      selected.datapoints.push(datapoint);
      this.highlight(selected.series, datapoint);
      return true;
    }
    return false;
  },

  <div id="method-Ext.ux.Flot-addSelected"></div>/**
   * ����Υǡ�������������֤��ɲä��ޤ�
   * @param {Object} seris �ɲä��������ݻ�����
   * @param {Object} datapoint �ɲä�����
   * @return {Boolean} �ºݤ� datapoint ���ɲä��줿��
   */
  addSelected: function(series, datapoint) {
    if (!this.selection || !series.selectable) {return false;}
    var selected = null, i, len;
    for (i = 0, len = this.selected.length; i < len; i++) {
      if (this.selected[i].series == series) { 
        selected = this.selected[i];
        break; 
      }
    }
    if (!selected) { 
      selected = {series: series, datapoints: []};
      this.selected.push(selected); 
    }

    return this.addSelectedPoint(selected, datapoint);
  },

  <div id="method-Ext.ux.Flot-selectAll"></div>/**
   * ���٤Ƥ��������򤷤ޤ�
   * @param {String/Object} _series ���٤Ƥ��������򤹤����
   * ����ʤ��ξ��ϡ����٤Ƥη�������򤷤ޤ�
   */
  selectAll: function(_series) {
    if (!this.selection) { return; }
    if (typeof _series == 'string') { _series = this.findSeries(_series); }
    var changed = false;
    var series = this.getData();
    this.selected = [];
    for (var i = 0, len = series.length; i < len; i++) {
      if (typeof _series != 'undefined' && _series != series[i]) { continue; }
      if (!series[i].selectable) { continue; }
      var selected = {series: series[i], datapoints: []};
      this.selected.push(selected);
      for (var j = 0, dlen = series[i].data.length; j < dlen; j++) {
        if (this.addSelectedPoint(selected, series[i].data[j])) {
          changed = true;
        }
      }
    }
    if (changed) { this.onSelectionChange(); }
  },

  <div id="method-Ext.ux.Flot-removeSelected"></div>/**
   * ����Υǡ�������������֤��餵���ޤ�
   * @param {Object} seris ���������ݻ�����
   * @param {Object} datapoint ������
   */
  removeSelected: function(series, datapoint) {
    for (var i = 0, len = this.selected.length; i < len; i++) {
      var s = this.selected[i];
      if (s.series == series) { 
        this.unhighlight(series, datapoint);
        s.datapoints.remove(datapoint);
        break; 
      }
    }
  },

  <div id="method-Ext.ux.Flot-unselectAll"></div>/**
   * ���ߤ��������ޤ�
   * @param {String/Object} _series
   */
  unselectAll: function(_series) {
    var changed = false;
    if (typeof _series == 'string') { _series = this.findSeries(_series); }
    for (var i = 0, len = this.selected.length; i < len; i++) {
      var s = this.selected[i];
      if (typeof _series != 'undefined' && _series != s.series) { continue; }
      for (var j = 0, dlen = s.datapoints.length; j < dlen; j++) {
        this.unhighlight(s.series, s.datapoints[j]);
      }
      changed = true;
      s.datapoints = [];
    }
    if (changed) { this.onSelectionChange(); }
  },

  <div id="method-Ext.ux.Flot-getSelected"></div>/**
   * ���򤵤�Ƥ��������� array ���֤��ޤ�
   * ���������� series �� datapoints ��������Ǥ�
<pre>
[{
  series: <series>
  datapoints: [[<x>, <y>], ...]
}, ...]

			
			</pre>
   * @return {Array} ���򤵤�Ƥ�������
   */
  getSelected: function() {
    return this.selected;
  },

  <div id="method-Ext.ux.Flot-getSelectedRecords"></div>/**
   * @param {Object} selected getSelected() �Ǽ����Ǥ������򤵤줿��
   * @return {Array} {@link Ext.data.Record} �����줿�ǡ�������
   */
  getSelectedRecords: function(selected) {
    var records = [];
    selected = selected || this.getSelected();
    for (var i = 0, len = selected.length; i < len; i++) {
      for (var j = 0, dlen = selected[i].datapoints.length; j < dlen; j++) {
        var dp = selected[i].datapoints[j];
        var xkey = selected[i].series.x2axis ? 'x2axis': 'xaxis';
        var idx = this.store.find(xkey, dp[0]);
        records.push(this.store.getAt(idx));
      }
    }
    return records;
  },

  // private
  setActionDisabled: function(key, disabled) {
    if (this.actions[key]) { this.actions[key].setDisabled(disabled); }
  },

  // private
  updateAction: function() {
    this.setActionDisabled('zoom',   this.selection.action === 'zoom');
    this.setActionDisabled('select', this.selection.action === 'select');
    this.setActionDisabled('move',   this.selection.action === 'move');
    var n_selected = 0, i, len;
    for (i = 0, len = this.selected.length; i < len; i++) {
      n_selected += this.selected[i].datapoints.length;
    }
    this.setActionDisabled('unselectall', this.selected.length === 0 || n_selected === 0);
    this.setActionDisabled('property',   !this.hasProperty());
    var item = this.clickItem || this.hoverItem;
    if (item) {
      n_selected = 0;
      for (i = 0, len = this.selected.length; i < len; i++) {
        if (this.selected[i].series == item.series) {
          n_selected = this.selected[i].datapoints.length;
          break;
        }
      }
      this.setActionDisabled('selectalldatapoint',   !item.series);
      this.setActionDisabled('unselectalldatapoint', !item.series || n_selected === 0);
      this.setActionDisabled('showseries',           !item.series.hidden);
      this.setActionDisabled('hideseries',           item.series.hidden);
    }
  },

  // private
  hasProperty: function() {
    return true;
  },

  // private
  showProperty: function() {
    if (!this.propertyCmp) {
      // ������ɥ�������
      this.propertyCmp = new Ext.Window({
        closeAction: 'hide',
        layout: 'fit',
        width: 400,
        height: 300,
        items: [{
          xtype: 'flotpropertygrid',
          flot: this,
          layout: 'fit'
        }]
      });
      // �Х���ǥ���
      var grid = this.propertyCmp.findByType('flotpropertygrid')[0];
      this.bindGrid(grid);
    }
    this.propertyCmp.show();
  },

  <div id="method-Ext.ux.Flot-bindGrid"></div>/**
   * Ext.ux.Flot �� Ext.grid.GridPanel ����ߤ˴�Ϣ�Ť��ޤ�
   * @param {Ext.grid.GridPanel} grid ��Ϣ�Ť��륰��å�
   */
  bindGrid: function(grid) {
    this.on('selectionchange', function(flot, selected) {
      var records = flot.getSelectedRecords(selected);
      var cm = this.getColumnModel();
      var sm = this.getSelectionModel();
      for (var i = 0, len = records.length; i < len; i++) {
        var rec = records[i];
        var x = this.store.indexOf(rec);
        for (var key in rec.data) {
          if (typeof rec.data.key != "undefined") {
            var y = cm.findColumnIndex(key);
            sm.select(x, y);
          }
        }
      }
    }, grid);
    grid.getSelectionModel().on('selectionchange', function(sm) {
    }, this);
  },

  // private
  showTooltip: function(event, pos, item) {
    if (!this.tooltip || this.disableTooltip) { return; }
    var c = {
      renderTo: Ext.getBody(),
      //targetXY: [item.pageX, item.pageY]
      targetXY: [pos.pageX, pos.pageY]
    };
    var tooltip = this.tooltip;
    if (typeof tooltip == 'boolean') { 
      tooltip = '<div id="{tipId}">{label} ({0}, {1})</div>'; 
    }
    if (typeof tooltip == 'string') { 
      if (!this.tipTemplate) {
        this.tipTemplate = new Ext.XTemplate(tooltip);
      }
      c.html = this.tipTemplate.apply({
        tipId:       event.target.id + '-tip',
        pageX:       pos.pageX,
        pageY:       pos.pageY,
        x:           pos.x,
        y:           pos.y,
        0:           item.datapoint[0],
        1:           item.datapoint[1],
        label:       item.series.label,
        color:       item.series.color,
        shadowSize:  item.series.shadowSize,
        dataIndex:   item.dataIndex,
        seriesIndex: item.seriesIndex
      });
    } else if (typeof tooltip == 'object') { 
      Ext.apply(c, this.tooltip); 
    }
    var tt = new Ext.ToolTip(c);
    tt.show();
  },

  <div id="method-Ext.ux.Flot-setTooltipDisable"></div>/**
   * �ġ�����åפ�ͭ��̵��ˤ��ޤ�
   * @param {Bool} disable false ��ͭ�� true ��̵��
   */
  setTooltipDisable: function(disable) {
    this.disableTooltip = disable;
  },

  <div id="method-Ext.ux.Flot-findSeries"></div>/**
   * ����򸡺����ޤ�
   * @param {String} name �����������̾
   * @return {Object} ���Ĥ��ä����� (���Ĥ���ʤ���� null)
   */
  findSeries: function(name) {
    var series = this.getData();
    for (var i = 0, len = series.length; i < len; i++) {
      var idx = series[i].dataIndex || series[i].label;
      if (name === idx || name === series[i].id) { return series[i]; }
    }
    return null;
  },

  // private
  setupSeries: function(series) {
    if (typeof series.length == 'undefined') {series = [series];}
    for (var i = 0, len = series.length; i < len; i++) {
      var s = series[i];
      if (typeof s.length != 'undefined') {s = series[i] = {data: s};}
      // baseSeries ��Ŭ��
      Ext.apply(s, this.baseSeries);
      // legend lines points bars pies ��ɬ�����
      Ext.applyIf(s, {
        id: Ext.id(null, 'flot-series'),
        /*
        lines:  Ext.apply({}, s.lines),
        points: Ext.apply({}, s.points),
        bars:   Ext.apply({}, s.bars),
        pies:   Ext.apply({}, s.pies),
        */
        legend: Ext.apply({}, s.legend),
        selectable: true,
        hidden: false
      });
    }
    return series;
  },

  <div id="method-Ext.ux.Flot-plot"></div>/**
   * flot �� plot ��ƤӽФ��ޤ���
   * @param {Array} series ���褹�����
   */
  plot: function(series) {
    // ��������Τ���˥��ԡ�����
    var _series = [];
    for (var i = 0, len = series.length; i < len; i++) {
      _series.push(Ext.apply({}, series[i]));
      if (this.flot) {
        // ������ξ�� axes ���������ͤ��ִ����ʤ���
        var axes = this.getAxes();
        var s = _series[i];
        if (s.xaxis && typeof s.xaxis != 'number') {
          s.xaxis = (s.xaxis == axes.x2axis) ? '2' : '1';
        }
        if (s.yaxis && typeof s.yaxis != 'number') {
          s.yaxis = (s.yaxis == axes.y2axis) ? '2' : '1';
        }
      }
    }
    if (this.fireEvent('beforedraw', this, _series) !== false) {
      this.flot = $.plot($('#' + this.id), _series, this);
      this.onDraw();
    }
  },

  <div id="method-Ext.ux.Flot-insertSeries"></div>/**
   * ����������� idx �ΰ��֤��������ޤ���
   * @param {Object} series �����������
   * @param {Number} idx ��������
   */
  insertSeries: function(series, idx) {
    var _series;
    _series = (this.flot) ? this.getData() : [];
    if (idx < 0) { idx = _series.length; }
    _series.splice(idx, 0, series);
    _series = this.setupSeries(_series);
    // FIXME ���κ���������Ǥ��Ƥ��ޤ�
    for (i = 0; i < _series.length; i++) { delete _series[i].color; }
    if (this.flot) {
      this.setData(_series);
      this.redraw();
    } else {
      this.series = _series;
    }
  },

  <div id="method-Ext.ux.Flot-prependSeries"></div>/**
   * �������������Ƭ���������ޤ���
   * @param {Object} series �����������
   */
  prependSeries: function(series) {
    this.insertSeries(series, 0);
  },

  <div id="method-Ext.ux.Flot-appendSeries"></div>/**
   * �����������������������ޤ���
   * @param {Object} series �����������
   */
  appendSeries: function(series) {
    this.insertSeries(series, -1);
  },

  <div id="method-Ext.ux.Flot-insertData"></div>/**
   * ����������򥫥��Ȥη��󷲤� idx �ΰ��֤��������ޤ���
   * @param {Object/Array} data ����ǡ���
   * @param {Object} series setupData() ���Ϥ��١�����������
   * @param {Number} idx ��������
   */
  insertData: function(data, series, idx) {
    var _series = this.setupData(data, series);
    for (var i = 0; i < _series.length; i++) {
      this.insertSeries(series[i], (idx < 0) ? idx : idx+i);
    }
  },

  <div id="method-Ext.ux.Flot-prependData"></div>/**
   * ����������򥫥��Ȥη��󷲤���Ƭ���������ޤ���
   * @param {Object/Array} data ����ǡ���
   * @param {Object} series setupData() ���Ϥ��١�����������
   */
  prependData: function(data, series) {
    this.insertData(data, series, 0);
  },

  <div id="method-Ext.ux.Flot-appendData"></div>/**
   * ����������򥫥��Ȥη��󷲤�������������ޤ���
   * @param {Object/Array} data ����ǡ���
   * @param {Object} series setupData() ���Ϥ��١�����������
   */
  appendData: function(data, series) {
    this.insertData(data, series, -1);
  },

  // private
  redraw: function() {
    var series = this.getData();
    if (this.fireEvent('beforedraw', this, series) !== false) {
      this.setupGrid();
      this.draw();
      this.onDraw();
    }
  },

  <div id="method-Ext.ux.Flot-setHidden"></div>/**
   * �����ɽ������ɽ�����ѹ����ޤ���
   * @param {String/Object} series ɽ������ɽ�������ꤹ�����
   * @param {Bool} hidden ɽ������ɽ������
   */
  setHidden: function(series, hidden) {
    var s = (typeof series == 'string') ? this.findSeries(series) : series;
    if (s.hidable === false) { return; }
    var keys = ['lines', 'points', 'bars', 'pies'];
    if (s.hidden != hidden) {
      s.hidden = hidden;
      for (var k = 0, len = keys.length; k < len; k++) {
        var key = keys[k];
        if (hidden) {
          s[key + 'Show'] = s[key];
          s[key] = Ext.applyIf({show: false, lineWidth: 0, fill: 0}, s[key]);
        } else {
          s[key] = s[key + 'Show'] || s[key];
        }
      }
      if (hidden) {
        s.colorShow  = s.color;
        s.color      = this.grid.backgroundColor || "#ffffff";
        s.shadowSizeShow = s.shadowSize;
        s.shadowSize = 0;
      } else {
        s.color      = s.colorShow;
        s.shadowSize = s.shadowSizeShow;
      }
      this.redraw();
      this.updateAction();
      this.fireEvent(hidden ? 'plothide' : 'plotshow', this, series);
    }
  },

  <div id="method-Ext.ux.Flot-setSelection"></div>/**
   * flot setSelection �Υ�åѡ�
   * @param {Object}  ranges ���򤹤��ϰ϶��
   */
  setSelection: function(ranges, preventEvent) {
    return this.flot.setSelection(ranges, preventEvent);
  },
  <div id="method-Ext.ux.Flot-clearSelection"></div>/**
   * flot clearSelection �Υ�åѡ�
   * �������ޤ���
   */
  clearSelection: function() {
    return this.flot.clearSelection();
  },
  <div id="method-Ext.ux.Flot-setCrosshair"></div>/**
   * flot setCrosshair �Υ�åѡ�
   * @param {Object}
   * flot 0.5 �Ǥ�̤�б��Ǥ���
   */
  setCrosshair: function(pos) {
    return this.flot.setCrosshair(pos);
  },
  <div id="method-Ext.ux.Flot-clearCrosshair"></div>/**
   * flot clearCrosshair �Υ�åѡ�
   * ���?�إ��ޡ����򥯥ꥢ���ޤ���
   * flot 0.5 �Ǥ�̤�б��Ǥ���
   */
  clearCrosshair: function() {
    return this.flot.clearCrosshair();
  },
  <div id="method-Ext.ux.Flot-highlight"></div>/**
   * flot highlight �Υ�åѡ�
   * @param {Nmuber) series index
   * @param {Number} datapoint index
   */
  highlight: function(series, datapoint) {
    return this.flot.highlight(series, datapoint);
  },
  <div id="method-Ext.ux.Flot-unhighlight"></div>/**
   * flot unhighlight �Υ�åѡ�
   * @param {Number} �оݤη���
   * @param {Number} �ϥ��饤�Ȥ�ä���
   */
  unhighlight: function(series, datapoint) {
    return this.flot.unhighlight(series, datapoint);
  },
  <div id="method-Ext.ux.Flot-setData"></div>/**
   * flot setData �Υ�åѡ�
   * @param {Array} ���ꤹ�����
   */
  setData: function(series) {
    return this.flot.setData(series);
  },
  <div id="method-Ext.ux.Flot-setupGrid"></div>/**
   * flot setupGrid �Υ�åѡ�
   */
  setupGrid: function() {
    return this.flot.setupGrid();
  },
  <div id="method-Ext.ux.Flot-draw"></div>/**
   * flot draw �Υ�åѡ�
   * �����Ȥξ��֤ǥ����Х�������褷�ޤ�
   */
  draw: function() {
    return this.flot.draw();
  },
  <div id="method-Ext.ux.Flot-getData"></div>/**
   * flot getData �Υ�åѡ�
   * @return {Array} �����Ȥ��ݻ�Ƥ�����������
   */
  getData: function() {
    return (this.flot) ? this.flot.getData() : this.series;
  },
  <div id="method-Ext.ux.Flot-getAxes"></div>/**
   * flot getAxes �Υ�åѡ�
   * @return {Object} ���ξ��� (xaxis yaxis x2axis y2axis)
   */
  getAxes: function() {
    return this.flot.getAxes();
  },
  <div id="method-Ext.ux.Flot-getCanvas"></div>/**
   * flot getCanvas �Υ�åѡ�
   * @return {Object} �����Х�
   */
  getCanvas: function() {
    return this.flot.getCanvas();
  },
  <div id="method-Ext.ux.Flot-getPlotOffset"></div>/**
   * flot getPlotOffset �Υ�åѡ�
   * @return {Object} �ץ�å��ΰ�Υ��ե��åȾ��� (left, bottom, right, top)
   */
  getPlotOffset: function() {
    return this.flot.getPlotOffset();
  }
});
Ext.reg('flot', Ext.ux.Flot);

<div id="cls-Ext.ux.Flot.grid"></div>/**
 * @class Ext.ux.Flot.grid
 * @singleton
 * flot �� grid �˴�Ϣ����᥽�åɷ��Ǥ���
 * Ext �� grid �Τ��ȤǤϤʤ��Τ���դ��Ƥ���������
 */
Ext.ns('Ext.ux.Flot.grid');

<div id="method-Ext.ux.Flot.grid-weekendMarkings"></div>/**
 * ������ޡ����󥰤��� flot �Υ���åɥƥ�ץ졼�ȤǤ�
 * �̾� grid.markings �˻��ꤷ�ƻȤ��ޤ�
 * ���� X �� (xaxis) ���Ф��ƤΤ�ͭ��Ǥ�
<pre>
grid: { markings: Ext.ux.Flot.grid.weekendMarkings }
</pre>
 * @param {Object} axes ������
 * @return {Array} �ޡ����󥰤����ϰϤ� Array ���֤��ޤ�
 * TODO yaxis x2axis y2axis ���б����Ƥ��ޤ���
 * @member Ext.ux.Flot.grid
 * @method weekendMarkings
 */
Ext.ux.Flot.grid.weekendMarkings = function(axes) {
  var markings = [];
  var d = new Date(axes.xaxis.min);
  // go to the first Saturday
  d.setUTCDate(d.getUTCDate() - ((d.getUTCDay() + 1) % 7));
  d.setUTCSeconds(0);
  d.setUTCMinutes(0);
  d.setUTCHours(0);
  var i = d.getTime();
  do {
    // when we don't set yaxis the rectangle automatically
    // extends to infinity upwards and downwards
    markings.push({ xaxis: { from: i, to: i + 2 * 24 * 60 * 60 * 1000 } });
    i += 7 * 24 * 60 * 60 * 1000;
  } while (i < axes.xaxis.max);

  return markings;
};

<div id="cls-Ext.ux.FlotPropertyGrid"></div>/**
 * @class Ext.ux.FlotPropertyGrid
 * @extends Ext.grid.GridPanel
 * Ext Flot ��ɸ��Υץ�ѥƥ��ѤΥ���åɤǤ���
 * flot.store �˥��åȤ���Ƥ������򥰥�åɤ�ɽ�����ޤ���
 * @constructor
 * @param {Object} config ���ꥪ�֥�������
 */
Ext.ux.FlotPropertyGrid = Ext.extend(Ext.grid.GridPanel, {
  // private
  initComponent: function() {
    var cm = [{
      header:    'X',
      dataIndex: 'xaxis',
      sortable:  true
    }, {
      header:    'X2',
      dataIndex: 'x2axis',
      hidden:    true,
      sortable:  true
    }];
    var series = this.flot.getData();
    for (var i = 0, len = series.length; i < len; i++) {
      var s = series[i];
      var renderer = function(value, cell, rec) {
        cell.css = 'background: ' + s.color;
        return value;
      };
      var c = {
        header:    s.label || _('Series') + ' ' + i,
        dataIndex: s.label || i,
        hidden:    s.hidden,
        renderer:  renderer,
        sortable:  true
      };
      cm.push(Ext.apply(c, this.basePropertyColumn));
    }

    Ext.applyIf(this, {
      store: this.flot.getStore(),
      cm: new Ext.grid.ColumnModel(cm),
      sm: new Ext.grid.CellSelectionModel({
        singleSelect: false
      }),
      viewConfig: {
        //columnsText: _('Columns'),
        emptyText: _('No Data')
      }
    });
    Ext.ux.FlotPropertyGrid.superclass.initComponent.call(this);
  }
});
Ext.reg('flotpropertygrid', Ext.ux.FlotPropertyGrid);

	
	</pre>
</body>
</html>